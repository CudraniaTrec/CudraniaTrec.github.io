---
layout: post
title: Blogging Like a Hacker
---

## 算分论文汇总

#### Mathematical Analysis of Algorithms

##### 两种算法分析策略

- Type A：针对具体问题的分析。具体到某个确定算法执行次数或者是存储空间层面的分析
  特点：起源悠久，可以针对同一个问题比较两个具体算法的优劣

- Type B：对一类问题整体分析，通过对一类问题的分析，我们试图找出最好的一个算法，或者是这类算法的上下界
  特点：可以一次分析“无穷多个”算法，并证明某个算法就是所有可能之中最优的。但是分析过程非常technology-dependent。针对算法好坏的微小定义差别都可能影响结果
- B类分析不会取代A类分析
  - 为了便于分析，B类方法通常要求我们简化模型，但简化之后可能最终产生一些现实中无法实现的算法。
  - 即使经过简化，B类方法依然很难处理，目前只解决了少数的问题。
    例子：计算$x^n$需要至少几次乘法目前也只有$n\leq12,n=20,21$得到了解决

##### In Situ Permutation（原地排列）问题

1. 问题描述：
   给定一个数组$(x_1,x_2...x_n)$经过变换，得到一个新数组$(x_{p(1)},x_{p(2)}...x_{p(n)})$,其中给定$(p(1),p(2)...p(n))$是$(1,2...n)$的一个置换。并且要求这一个过程之中<u>只能使用常数大小的额外空间</u>。

2. cycle leader方法

   - 算法流程

   $$
   \begin{array}{clc}
   1 & \text { for } j:=1 \text { step } 1 \text { until } n \text { do } & 1 \\
   2 & \text { begin comment the permutation has been } & n \\
   3 & \text { done on all cycles with leader }<j ; & n \\
   4 & k:=p(j) ; & n \\
   5 & \text { while } k>j \text { do } & n+a \\
   6 & \quad k:=p(k) ; & a \\
   7 & \text { if } k=j \text { then } & n \\
   8 & \text { begin comment } j \text { is a cycle leader; } & b \\
   9 & \quad y:=x[j] ; l:=p(k) ; & b \\
   10 & \quad \text { while } l \neq j \text { do } & b+c \\
   11 & \quad\quad \text { begin } x[k]:=x[l] ; k:=l ; l:=p(k) \text { end } ; & c \\
   12 & \quad x[k]:=y ; & b \\
   13 & \text { end permutation on cycle; } & b \\
   14 & \text { end loop on } j . & n
   \end{array}
   $$

   - 算法思想:

     $(p(1),p(2)...p(n))$作为**一个置换可以看做许多个轮换的组合，也就是映射关系构成的一个个圈**。我们通过找到每个圈的最小值作为cycle leader,然后从他为首，将这个圈上的元素一一完成变换（上式中的9-12行），由于每个圈只会被执行一次，因此这个算法成立。

   - 算法初步分析：
   
     - 利用“<u>基尔霍夫定律</u>”，我们知道进入算法某行的总次数就是从某行出来的总次数。因此我们可以简单的将每一行执行次数写在该行的右侧，并简化到全部可以用n与3个变量a,b,c来表示。
   
     - 由于b是所有圈的个数，而c是每个圈之中除开cycle leader之外其他元素的个数（每个元素都会被改变恰一次），因此$b+c=n$。那么假设b（圈的个数）已经是已知的值了，现在就只剩下a的值。
     - 我们称从每个元素出发，沿着圈一直走，可以再几步之内到达第一个不大于他的数，为这元素的”距离“。那么a代表的是对所有的元素的”距离“求和。

	- 算法进阶分析：
	
	  - $(p(1),p(2)...p(n))=(1,2...n)$的时候，整个置换就是n个一元圈的组合，此时$a=0,b=n$a是最好情形，b是最坏情形。$(p(1),p(2)...p(n))=(2,3...n,1)$的时候，n个元素共同组成一个大圈。此时$a=\frac{n^2-n}{2},b=1$。 a是最坏情形,而b最好。
	  
	  - 接下来我们试图对平均情形加以分析，现在假设n!种排列是等可能出现的。我们首先对排列$(p(1)...p(n))$加以变换变成$(q(1),q(2)...q(n))$。具体为：
	    1. 将其按照映射关系拆分为若干个圈（轮换）
	    2. 每个圈将leader写在开头
	    3. 所有的圈按照leader的递减次序排列
		  4. 将排列之后的结果直接组成一个新的数组
		  
		  例如$(8,2,7,1,6,9,3,4,5)\rightarrow(184)(2)(37)(569)\rightarrow(5,6,9,3,7,2,1,8,4)$
		
		- 针对$(q(1)...q(n))$分析。b是p之中的圈的数量，转换过后就是q之中满足比自己左边所有的数小的数的数量（这样的数也就是所有的leader）。经过前人的分析，满足b=k的所有排列共有$\left[\begin{array}{c}n\\k\end{array}\right]$个（第一类Stirling数）。而b的平均与方差则是$E(b)=H_n,Var(b)=H_n-H_n^2$。其中$H_n=1+\frac{1}{2}+...+\frac{1}{n},H_n^2=1+\frac{1}{4}+....+\frac{1}{n^2}$是1阶，2阶调和级数。
		
		- 考虑a。每个元素$q(i)$的“距离”就是$q(i+1),q(i+2)...q(i+r)$这样寻找下去第一个$q(i+r)<q(i)||i+r>n$。也就是所有满足$q(i)=min_{k=i}^{j}\{q(k)\}$的j的数量。因此我们定义
		  $$
		  y_{ij}=\left\{\begin{array}{ll}1&q(i)=min_{k=i}^{j}\{q(k)\}\\0&else\end{array}\right.
		  $$
		  则有$a=\sum y_{ij}$，并且我们记$\overline{y}_{ij}=E(y_{ij})$。对所有排列一起考虑，$y_{ij}=1$就等价于对于$q(i),q(i+1)...q(j)$这j-i+1个数随机排列使得最小的数出现在开头的概率，也就是$\frac{1}{j-i+1}$。因此
		  $$
		  E(a)=\overline{a}=\sum\overline{y}_{ij}=\sum\frac{1}{j-i+1}=\sum_r\frac{n+1-r}{r}=(n+1)H_n-2n
		  $$
		  对于a的方差分析较为复杂，不在此具体推导，最终结果是
		  $$
		  Var(a)=2n^2-(n+1)^2H_n^2-(n+1)H_n+4n
		  $$
		
		- 综合上述结果：
		  $$
		  \begin{array}{c|c|c|c|c}&min&max&aver&dev(标准差)\\a&0&\frac{n^2-n}{2}&nlnn+O(n)&\sqrt{2-\frac{\pi^2}{6}}n+O(lnn)\\b&1&n&lnn+O(1)&\sqrt{lnn}+O(1)\end{array}
		  $$
		  因此平均情况下整个算法执行$nlogn$步

3. 算法的改进

  1. **添加tally。**

     添加变量tally,初始值n。在算法的12行添加


  ```c
  tally--;if(tally==0)goto exit;
  ```

  这样整个算法只需要遍历$p(i)$数组时，把所有的圈都经过至少一次即可。特别的，由于cycle leader是最先被遍历到的元素，所以只需要经过所有的leader。进一步，只需要保证经过了最大的leader，也就是变换之后的$q(1)$即可。

  - 4-7行的减少

    由上述分析，我们知道4-7行无需遍历所有的点，而是经过q(1)即可结束，因此减少n-q(1)次，平均情况下节省了$\frac{0+1+2+...+(n-1)}{n}=\frac{n-1}{2}$次
    
    进一步分析程序的主要循环第6行，也就是a。我们知道在q(1)之后出现的元素都无需被遍历，也就是$\forall q(i)>q(1),y'_{ij}=0$平均情况的节省是
    $$
    \sum_{2\leq i<j\leq n}y_{ij}(if\ q(1)<q(i))
    $$
    对于确定的i,j。上式中的$y_{ij}(if\ q(1)<q(i))=1$可看做$q(1),q(i),q(i+1)...q(j)$这个j-i+2长的数组随机排列下恰好最小的排在第1位，次小的排在第2位的概率，因此平均情况下的节省就是
    $$
    \sum_{2\leq i<j\leq n}\frac{1}{(j-i+1)(j-i+2)}=\sum_{r=2}^n\frac{n-r}{r(r+1)}\\
    =n\sum_{r=2}^n(\frac{1}{r}-\frac{1}{r+1})-\sum_{r=2}^n\frac{1}{r+1}=n(\frac{1}{2}-\frac{1}{n+1})-H_{n+1}+1+\frac{1}{2}\\
    =\frac{n+1}{2}+\frac{1}{n+1}-H_{n+1}
    $$

  2. 开头元素一定是cycle leader

     利用1一定是leader。可以在j=1的时候跳过5,6行直接进入8行,减少了一次对这个圈中其他元素的遍历。因此平均情况下也能减少$\frac{n-1}{2}$次第6行的执行

  3. **获得反函数**
     虽然我们再次因为空间受限，无法获得p的反函数。但假设我们也有p的反函数$p^-$，则可以针对第5,6行进行优化。具体表现为当搜寻的结果始终比j大的时候，我们改为按照$p(j),p^-(j),p(p(j)),p^-(p^-(j))...$这样的次序双向的搜索。这样虽然在平均情况下算法的时间复杂度依然是O(nlogn)，但最坏情况的时间复杂度也降到了O(nlogn)。我们在此无法给出证明，但是可以给出最坏情况的例子。

  - 构造p使得n个元素组成一个圈。假设获得$p(j),p^-(j)$加起来也只花单位时间。
    我们试图构造这样一个圈，使得每个元素沿着顺时针或逆时针方向走到距离自己最近的，第一个不大于他的元素的路径长度之和最大，记为$f(n)$。
    考虑从1到2顺时针方向需要经过k步，$1\leq k<n$，那么假设1在位置i，2在位置i+k则从2走到1需要$min\{k,n-k\}$步，在分别考虑处于位置$i,i+1...i+k-1;i+k,i+k+1...i-1$的这两组点，可以看做k,n-k的情形划归，所以得到递归式：

  - $$
    f(1)=0\\
    f(n)=\mathop{max}_k(min\{k,n-k\}+f(k)+f(n-k))
    $$

    解递归式，得到$f(2^{a_1}+2^{a_2}+...+2^{a_m})=\frac{1}{2}(\sum_{i=1}^m(a_i+2i-2)2^{a_i}),a_1>a_2>...a_m$（也可以用归纳法直接验证这个结论成立）。可见此时最坏情况时间复杂度是O(nlogn)

  4. 自动机模型

![AutoM](D:\桌面文件\Course\大二下\算法设计与分析\paper\static\AutoM.png)

##### Selecting The $t_{th}$ Largest

1. 问题描述
   给定一个数组$(x[1],x[2]...x[n])$并且其中的元素互不相同，那么对t，找出其中第t大的数。

2. Hoare 的解法
   类似于快排，我们每次先找一个轴值k，然后通过n-1次比较将比他小的放在前面，比他大的放在后面。这样若k处在位置t，那么k即为所求。反之则在前面的数之中寻找第k大的数或者在后面的数之中寻找第(t-k的位置)大的数即可。

3. 时间复杂度分析
   假设给定n,k。上述方法的平均比较次数是$C_{n,k}$。同样类似于快速排序，我们可以写出递归式
   $$
   C_{1,1}=0\\
   C_{n,t}=n-1+\frac{1}{n}(A_{n,t}+B_{n,t})\\
   A_{n,t}=C_{n-1,t-1}+C_{n-2,t-2}+...C_{n-t+1,1}\\
   B_{n,t}=C_{t,t}+C_{t+1,t}+...C_{n-1,t}
   $$
   不难看出，$A_{n,t}$就是表示目标在k后面的所有情形，而$B_{n,t}$就代表了目标在k前面的所有情形
   递归式的求解同样请参见论文，在此不做展开，整体思路是先尝试通过做差消去A,B。然后对得到的关于C的等式换元分析，最后可以求得
   $$
   C_{n,k}=2((n+1)H_n-(n+3-t)H_{n+1-t}-(t+2)H_t+n+3)
   $$
   显然，问题的复杂度是O(nlogn)级别的。

   特别的，对于求中位数问题，也就是n=2t-1.我们可以得到时间复杂度是
   $$
   (4+4ln2)t-8lnt+1-8\gamma+O(t^{-1})
   $$
   
4. 后人的工作
   1. Tarjan证明了最多5.2n次比较就可以完成算法，这也就是我们课上的Select算法
   2. Floyd给出了寻找中位数的$\frac{3}{2}n+O(n^{\frac{2}{3}}logn)$次比较的算法，并且证明了平均情况下至少要$\frac{5}{4}n+o(n)$次比较



#### Primes Is In P

因为本文之中数论方面technical的证明较多，详情请参见原论文。但引理标号与原文保持一致，由于我对原文的证明过程有一点改动，所以可能标号看着有点怪。

##### 问题背景

人们一直试图找出如何高效的判断一个数是否是素数的算法，一个简单的思路是对n用$1,2...\sqrt{n}$一一代入来判断是否是n的因子，这样的时间是$O(\sqrt{n})$量级的。人们试图将时间缩小到logn的多项式量级，但之前的算法要么是无法达到这一目的，要么是采用了不确定性的算法，亦或是使用了黎曼猜想来证明。直到这篇论文，给出了确定性的$O((logn)^{\frac{15}{2}})$的算法

##### 引理与记号准备

###### 费马小定理

p素数
$$
a^p\equiv a\;mod\;p\\
a^{p-1}\equiv 1\;mod\;p\quad(p\nmid a)
$$

###### 引理2.1

$$
a\in Z,n\in N,n\geq2\\
p是素数\Leftrightarrow (x+a)^n\equiv x^n+a(mod\;n) 
$$

两边做差，利用$n\lvert C_n^i,i\in\{1,2...n-1\}$等价于n是素数即可证明

###### 引理3.1

$LCM(m):=lcm\{1,2...m\}$为前m个正整数的最小公倍数
$$
m\geq7\rightarrow LCM(m)\geq2^m
$$


###### 记号

1. $Z_n,F_p$分别是模n的整数环以及p元有限域。
2. $O^{\backsim}(t(n)):=O(t(n)\cdot poly(log\;t(n)))$。相当于在原来的基础上适当添加log的多项式时间复
3. $\Phi(n)$表示n的欧拉函数，$(a,n)=1,a^{\Phi(n)}\equiv1(mod\; n)$
   $o_r(a):=\mathop{min}\limits_{k}\{a^k\equiv 1(mod\;n)\}$表示a模r的阶。$o_r(a)\lvert\Phi(r)$
4. 如果h(x)是一个d次整系数多项式，那么$Z_n[x]/(h(x))$是$n^d$阶的一个除环，$f(x)\equiv g(x)(mod\;h(x),n)$表示这个除环之中的f(x)=g(x)
5. 如果多项式f(x)与整数m满足$f^m(x)\equiv f(x^m)(\bmod x^r-1,p)$，那么我们就说m对f是introspective的
   不难发现：
   1. m,m'对f是introspective，则mm'也对f是introspective的 (**Lemma4.5**)
   2. m对f,g是introspective，则m对f(x)g(x)也是introspective的 (**Lemma4.6**)



##### 算法描述

我们由引理2.1得到启发，试图通过模$x^r-1$来减少多项式的项数，其中r是一个较小的数。这样，我们只需验证n的素性通过：
$$
(x+a)^n=x^n+a(mod\;x^r-1,n)
$$
但只需要经过一个恰当选择的r以及少数几个a就能达成目标

###### 算法伪代码

Input: integer $n>1$.
1. If $\left(n=a^{b}\right.$ for $a \in \mathcal{N}$ and $\left.b>1\right)$, output COMPOSITE.
2. Find the smallest $r$ such that $o_{r}(n)>\log ^{2} n$.
3. If $1<(a, n)<n$ for some $a \leq r$, output COMPOSITE.
4. If $n \leq r$, output PRIME. 
5. For $a=1$ to $\lfloor\sqrt{\phi(r)} \log n\rfloor$ do
if $\left((X+a)^{n} \neq X^{n}+a\left(\bmod X^{r}-1, n\right)\right)$, output COMPOSITE;
6. Output PRIME.



##### 正确性证明

###### 引理4.2

n是素数则算法会输出PRIME

显然1，3行不可能输出COMPOSITE，利用引理2.1可得5行也不可能输出COMPOSITE

###### 引理4.3

$\exists r\leq max\{3,\left\lceil\log ^{5} n\right\rceil\}$使得$o_r(n)>log^2n$

证明见原文



利用引理4.2。接下来我们需要证明输出PRIME的时候,n就一定是素数。如果是第4行输出的PRIME，那么就说明我们在第三行已经对所有的a=1,2...n-1查看了最大公约数(a,n)=1，这就已经说明n是一个素数了。（事实上当n较大时我们随后可以证明r一定会<n）所以我们现在知道算法通过了前5步并且没有停机。

按照之前所述的思想，我们可以先证明r有一个不大的上界，也就是引理4.3的上界。现在利用4.3我们已经选出了r，由于$o_r(n)>log^2n>1$，因此也存在n的一个质因子p使得$o_r(p)>1$。我们可以简单推出(n,r)=1,p>r（否则程序在第3,4行就会结束）。

下面我们令$l=\lfloor\sqrt{\phi(r)} \log n\rfloor$也就是算法之中a的范围，我们现在证明对于$a=1...\lfloor\sqrt{\phi(r)} \log n\rfloor$使得第5行之中的$\left((X+a)^{n}= X^{n}+a\left(\bmod X^{r}-1, n\right)\right)$全部成立的n只会是素数。

首先我们进行简单的推导
$$
\begin{align}
(X+a)^{n}&=X^{n}+a\left(\bmod X^{r}-1, n\right)\\
\Rightarrow (X+a)^{n}&=X^{n}+a\left(\bmod X^{r}-1, p\right)\\
\Rightarrow (X+a)^{\frac{n}{p}}&=X^{\frac{n}{p}}+a\left(\bmod X^{r}-1, p\right)
\end{align}
$$
最后一行的成立是因为
$$
x^{\frac{n}{p}}\equiv x^n\equiv (x+a)^n-a=((x+a)^{\frac{n}{p}})^p-a=(x+a)^{\frac{n}{p}}-a\left(\bmod X^{r}-1, p\right)
$$
利用引理2.1也可以得到
$$
\Rightarrow (X+a)^{p}=X^{p}+a\left(\bmod X^{r}-1, p\right)
$$
现在利用之前所述的引理4.5,4.6我们可知$I=\left\{\left(\frac{n}{p}\right)^{i} \cdot p^{j} \mid i, j \geq 0\right\}$之中的任意数对于$P=\left\{\prod_{a=0}^{\ell}(X+a)^{e_{a}} \mid e_{a} \geq 0\right\}$之中的任意多项式都是introspective的

我们构造两个集合继续论证

1. $G=\{z\in Z_r|\exists i\in I,i\equiv z(\bmod r)\}$。由于$(n,r)=(p,r)=1$可知$0\notin G$。
   令$|G|=t$，则$o_r(n)>log^2n\Rightarrow t>log^2n$

   又因为$\Phi(r)$表示$Z_r$之中所有与r互素的数的个数，故而$t\leq\Phi(r)$

2. 利用分圆多项式的性质，$F_p$上的r次分圆多项式$Q_r(x)$将$x^r-1$及其因子划分为$o_r(p)$次的不可约因子。
   现在假设h(x)就是这样的一个因子。那么我们就定义第二个集合：
   $$
   \mathcal{G}=\{f(x)\in F_p[x]/(h(x))|\exists f'\in P,f\equiv f'(\bmod h(x,p))\}
   $$
   

针对第二个集合的大小，我们由如下两个引理加以限制

1. ###### 引理4.7

   $$
   |\mathcal{G}| \geq\left(\begin{array}{c}
   t+\ell \\
   t-1
   \end{array}\right)
   $$

2. ###### 引理4.8

   $$
   \text { If } n \text { is not a power of } p \text { then }|\mathcal{G}| \leq n^{\sqrt{t}}
   $$

   

现在就可以完成证明了！

$t,\ell$的定义同上文
$$
\begin{array}{rlr}
|\mathcal{G}| & \geq\left(\begin{array}{c}
t+\ell \\
t-1
\end{array}\right) & \\
& \geq\left(\begin{array}{c}
\ell+1+\lfloor\sqrt{t} \log n\rfloor \\
\lfloor\sqrt{t} \log n\rfloor
\end{array}\right) & (\text { since } t>\sqrt{t} \log n) \\
& \geq\left(\begin{array}{c}
2\lfloor\sqrt{t} \log n\rfloor+1 \\
\lfloor\sqrt{t} \log n\rfloor
\end{array}\right) & (\text { since } \ell=\lfloor\sqrt{\phi(r)} \log n\rfloor \geq\lfloor\sqrt{t} \log n\rfloor)\\
& >2^{\lfloor\sqrt{t} \log n\rfloor+1} & \left(\text { since }\lfloor\sqrt{t} \log n\rfloor>\left\lfloor\log ^{2} n\right\rfloor \geq 1\right)\\
& \geq n^{\sqrt{t}}
\end{array}
$$
但这显然与引理4.8矛盾，所以利用引理4.8的前置条件可知n是p的幂次，但如果幂次大于1就会被算法的第一行检测出来，所以n=p，n就是素数。

##### 算法复杂度分析

我们先重温一下整个算法

Input: integer $n>1$.

1. If $\left(n=a^{b}\right.$ for $a \in \mathcal{N}$ and $\left.b>1\right)$, output COMPOSITE.
2. Find the smallest $r$ such that $o_{r}(n)>\log ^{2} n$.
3. If $1<(a, n)<n$ for some $a \leq r$, output COMPOSITE.
4. If $n \leq r$, output PRIME. 
5. For $a=1$ to $\lfloor\sqrt{\phi(r)} \log n\rfloor$ do
   if $\left((X+a)^{n} \neq X^{n}+a\left(\bmod X^{r}-1, n\right)\right)$, output COMPOSITE;
6. Output PRIME.

现在一步一步分析时间复杂度。

1. 第一步的花费分作3个步骤
   1. 遍历所有b，由于$b\leq logn$所以最多进行$\log n$次
   2. 对于固定的b，二分查找a，最多进行logn次
   3. 对于a,b，计算出$a^b$花费$O^{\backsim}(\log n)$次

​	总花费是三者相乘，总共$O^{\backsim}(log^3n)$

2. 第二步首先最多只需验证$O(\log^5n)$个r
   其次对每个r，要依次计算至多$O(log^2n)$个k来确认是否$n^k\neq1(\bmod r)$，这会涉及$O(\log^2n)$次乘法运算以及相应的模r运算的开销，总共$O^{\backsim}(\log^2n\log r)$因此总花费是$O^{\backsim}(\log^7n)$

3. 由于辗转相除法的时间复杂度是$O(\log n)$量级，又最多有$O(\log^5n)$个数需要和n验证，所以总花费是$O(\log^6n)$

4. 第四部开销$O(\log n)$

5. 第五步之中有至多$\ell=\lfloor\sqrt{\phi(r)} \log n\rfloor$个等式需要验证

   对于固定的a，我们将在模$x^r-1$的条件之下，将等式两边都看作r次多项式计算，计算左边可以用二分递归的方式（类似于快速幂算法），共需要$O(\log n)$次乘法，每次乘法需要计算r个参数，每个参数都是模n意义下的，一次加法至多需要$O(\log n)$的时间。
   现在将上述所有式子乘起来，并利用$\phi(r)<r$可得总时间花费是$O(\log^{\frac{21}{2}}n)$。这显然就是整个算法的主导时间开销。

##### 算法进一步提升

我们注意到想要进一步减少算法的时间复杂度上界，只需要证明我们能够更快地找到r即可，也就是缩小r的上界。事实上，如果我们能够将r限制在$O(\log^2n)$的范围之内，就能够直接代入上面的分析得到算法的时间复杂度是$O^{\backsim}(\log^6n)$

1. Artin 猜想
   如果n不是一个完全平方数，那么对于正整数m，满足$q<m$并且$o_q(n)=q-1$的素数q的渐进个数是$A(n)\frac{m}{\ln m}$个，其中$A(n)>0.35$是Artin常数
2. Sophie-Germain 素数密度猜想
   满足$q<m$并且$2q+1$也是素数的素数q的渐进个数是$\frac{2C_2m}{\ln^2m}$，其中$C_2$是孪生素数常数，约为0.66

如果Artin 猜想成立，那么我们就可以证明$m=O(\log^2n)$，如果Sophie-Germain 素数密度猜想成立，那么就有$m=O^{\backsim}(\log^2n)$。当然这两者都可以推出$m=O^{\backsim}(\log^6n)$

事实上，我们也可以用现有的定理来进一步分析

###### Fou 引理

假设P(m)表示m的最大质因子。存在常数c,n~0~使得对于所有的x>n~0~：
$$
\mid\left\{q \mid q \text { is prime, } q \leq x \text { and } P(q-1)>q^{\frac{2}{3}}\right\} \mid \geq c \frac{x}{\ln x}
$$
利用这个引理我们可以知道满足$P(q-1)>q^{\frac{2}{3}}$的素数q“密度相当高”。所以我们就可以在$O(log^3n)$的时间之内找到r。这样也可以把时间复杂度提升到$m=O^{\backsim}(\log^{\frac{15}{2}}n)$



##### 未来工作

###### 猜想

若r是一个不整除n的素数，并且$(X-1)^{n}=X^{n}-1\left(\bmod X^{r}-1, n\right)$那么要么n是一个素数,要么$n^2\equiv1(\bmod r)$

如果这个猜想成立，那么我们甚至可以改变对r的搜索策略，转为搜索第一个不整除$n^2-1$的素数，这样的r可以在$O(\log n)$之内被找到，进而我们在第5步就只需要验证猜想之中的等式是否成立。这个验证过程与之前一样需要$O^{\backsim}(r\log^2n)$的时间复杂度，因此最终复杂度仅为$O(\log^3n)$!